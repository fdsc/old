// Выявленное качество кода 12,07 на 100 строк кода (7 ошибок)
// Анализ выполнен приблизительно за 180 минут 58-ми строк кода: по 3 минуте и 6 секунд на строку кода
// После запуска (после 2-ого анализа) выявлена ещё одна ошибка. Пропущена по причине невнимания к некоторым изменениям (13,79 ошибок на 100 строк кода)
/*
 * key
 * e11  недопустим null
 * e12  пустой массив
 * e13  массив с длинной больше нуля
 * 
 * oiv
 * e21  null
 * e22  пустой массив
 * e23  массив с длинной больше нуля
 * 
 * compressedOpenText
 * e31  недопустим null
 * e32  пустой массив
 * e33  массив с длиной больше нуля
 * e34  массив с длиной 1
 * e35  массив с длиной 71
 * e36  массив с длиной 72
 * e37  массив с длиной 73
 * 
 * encrypt
 * e41  encrypt==true
 * e42  encrypt==false
 * 
 * */

/*
 * key должен содержать ключ и не быть null, по использованию не уничтожаетя
 * compressedOpenText не null и должен содержать шифруемый текст
 * 
 * */
public unsafe void CFB(byte[] key, byte[] oiv, byte[] compressedOpenText, bool encrypt)
{
    // инициализация объекта шифрования SHA3
    // параметр коструктора не имеет решающего значения
    // !4 объект шифрования должен быть безопасно уничтожен функцией clear
-!- // !4-: объект шифрования не уничтожается
    var sha  = new SHA3(compressedOpenText.Length);

    // инициализация ключём объекта шифрования
    // объект шифрования sha инициализируется значением ключа key
    // второй параметр false говорит, что объект sha пока не инициализирован
(1) // результат возвращается, только если oiv == null, то есть если не задан вектор инициализации
    // вектор инициализации может быть не задан, при этом тогда инициализирующий блок init действительно должен быть инициализирован
    // по схеме CFB init должен пойти в первый блок гаммы и затем более нигде не используется

+   //!1 ключ key более нигде не используется, т.к. вместо него используется состояние объекта шифрования sha. key не уничтожается
+   //!2 объект шифрования sha не должен потерять инициализацию
+   //!3 объект шифрования sha должен использовать своё состояние в при шифровании всегда
-   //!5 объект init должен быть безопасно уничтожен
(2) var init = sha.getDuplex(key, false, -1, oiv == null);

    // !1+: объект key более нигде не используется, копий объекта в других указателях или объектах нет

    if (oiv != null)
    {
        // !2+: объект используется с условием, что он уже инициализирован (второй параметр - isInitialized = true)
        // !5+: объект init перезаписывается, однако только в том случае, если oiv != null , а значит, если объект не создан см. (1)
(3)     init = sha.getDuplex(oiv, true);
    }

    // создание блока для шифрования
+   // !6 объект block должен быть безопасно уничтожен - не требуется, так как в объекте одни нули
+   // !7 объект block имеет индексы на запись не более [0; +1; 70] (71 элемент)
    var block = new byte[71];

    // объект block инициализируется
    // при создании выше он уже инициализирован нулями
    // объект init не может быть менее 72-х байт, поэтому проверки на то, что он меньше не нужны
    // объект init инициализирован в (2), если oiv == null
    // объект init инициализирован в (3), если oiv != null
    // oiv == null или oiv != null равно true, следовательно объект init инициализирован всегда
    // объект init - инициализирован безусловно
    // объект block имеет ненулевую длинну, готов принять в себя информацию
    // длина объекта init больше длины block:
    //      1. весь block будет проинициализирован
    //      2. не будет нарушена память за block, т.к. функция CopyTo защищает от этого
    // !7+: выполнено, т.к. верен пункт 2
    // !6=
+   // !8 объект block должен быть использован
-   // !9 текущее значение объекта block должно быть безопасно уничтожено
    BytesBuilder.CopyTo(init, block, 0, 71, init.Length < 71 ? 0 : init.Length - 71);

-!- // !5-: объект init более не встречается в тексте программы, однако не уничтожен безопасно

    // Переменная compressedOpenText имеет копию указателя
    fixed (byte * o_ = compressedOpenText)
    {
        // ещё копии указателей
        UInt64 * o  = (UInt64 *) o_;
        UInt16 * o2 = (UInt16 *) o_;

        // создаётся переменная i
        // compressedOpenText инициализирован
        // compressedOpenText.Length >= 0
        // цикл сработает хотя бы один раз, если compressedOpenText.Length > 0
(5)     // i в начале цикла всегда в границах диапазона индексов compressedOpenText
        for (int i = 0; i < compressedOpenText.Length; i += 72)
        {
            // !2+: объект используется с условием, что он уже инициализирован (второй параметр - isInitialized = true)
            // !2+: далее в коде объект не используется
            // !3+: объект используется только с функцией getDuplex с предварительной инициализацией, не теряет инициализацию
            // !9с: объект c должен быть безопасно уничтожен
-!-         // !9с-: объект c в тексте программы не уничтожается безопасно
            // происходит шифрование с ключевым внутренним состоянием (второй параметр - true)
            // шифруется block
            // block содержит синхропосылку, если это первая итерация цикла
            // если это следующие итерации цикла то:
            // если !encrypt, то block содержит кусок шифротекста предудыщего блока
            // если encrypt, то block содержит кусок шифротекста предыдущего блока
            // алгоритм CFB в данной позиции верен
            // !8+
            var c = sha.getDuplex(block, true);

            // !9+: объект block безопасно уничтожен
            BytesBuilder.ToNull(block);

            // По алгоритму CFB при шифровании блок шифротекста шифруется с ключём (в данном случае, с внутренним состоянием)
            // При расшифровании блок шифротекста также должен быть зашифрован с ключём
            // При шифровани шифротекст содержится в блоке compressedOpenText после прменения к нему операции xor
            // При расшифровании шифротекст содержится в блоке compressedOpenText перед расшифрованием соответствующего блока

            // !11: предыдущий блок шифротекста должен быть зашифрован и передан на вход операции xor
+           // !12: синхропосылка (вектор инициализации) должна быть зашифрована, это сделано в (2) или в (3)
            // Строки (4) копируют 71 байт из compressedOpenText в block
            // Учитывая, что encrypt - наличие зашифрования
            // !encrypt - условие расшифрования
            // Таким образом, операция осуществляется только при шифровании
            // В compressedOpenText при шифровании расположен блок шифротекста
            // В функции CopyTo выход за пределы диапазона индексов невозможен
            // block длиной 71 байт может принять блок длиной 71 байт
            // compressedOpenText не обязательно содержит 71 байт данных, тем более, начиная с индекса i
            // индекс i остался в пределах диапазона индексов compressedOpenText, как указано в (5), так как не изменялся ни i, ни длина compressedOpenText
+           // !14: в ходе цикла длина compressedOpenText не изменяется
            // таким образом, при отсутствии в compressedOpenText достаточной информации, block будет заполнен не полностью, однако хотя бы один байт будет записан из compressedOpenText
            // block ранее обнулён, поэтому на месте недостающих байт будут нули
+           // !15: учесть при зашифровании, что на месте недостающих байт шифротекста также должны быть нули
-!-         // !13: объект block должен быть безопасно уничтожен
(4)         if (!encrypt)
(4)             BytesBuilder.CopyTo(compressedOpenText, block, 0, 71, i);

            // !14+: чтение compressedOpenText не изменяет его длину, в том числе, чтение по указателю o и o_
            // Если после индекса i имеется блок данных не менее 71-ого байта в длинну
            // действительно, если i < compressedOpenText.Length, то имеется не менее 1 байта, включая i-ый
            // если i+1 - не менее 2-х байт
            // если i+70 - не менее 71-ого байта
-!-
(7)         if (i+70 < compressedOpenText.Length)           // примечание: при анализе 71 сразу было исправлено на 70
            fixed (byte * b_ = c)
            {
                UInt64 * b  = (UInt64 *) b_;
                UInt16 * b2 = (UInt16 *) b_;

                o[0] ^= b[0];       // перезапись байтов 0-7
                o[1] ^= b[1];       // байтов 8-15
                o[2] ^= b[2];       // байтов 16-23
                o[3] ^= b[3];       // байтов 23-31

                o[4] ^= b[4];       // байтов 32-39
                o[5] ^= b[5];       // байтов 40-47
                o[6] ^= b[6];       // 48-55
                o[7] ^= b[7];       // 56-63

                o2[32] ^= b2[32];   // 64-65
                o2[33] ^= b2[33];   // 66-67
                o2[34] ^= b2[34];   // 68-69

                o_[70] ^= b_[70];   // 70

                // итого наложено xor из b_, b2 и b на o_, o2 и o 70 байт
                // байты наложены неверно, так как на один и тот же кусок открытого текста налагаются разные куски гаммы в цикле
                // на самом деле это наложение байт открытого текста на байты гаммы
-!-
                // в b есть нужное количество байт, так как в нём 71-н байт, а индекс 70 есть как раз максимальный индекс этого массива
                // в o есть нужно количество байт, так как условие (7) выполняется
                // !7+
            }
            else
            // !14+: чтение compressedOpenText не изменяет его длину, в том числе, чтение по указателю o и o_
            
            for (int j = 0; j + i < compressedOpenText.Length && j < 71; j++)
            {
                // в объекте c 72 байта, j всегда менее 71, так как блок содержит лишь 71-н байт
-!-             // j - неверный индекс
                // верный индекс j+i, он всегда менее длинны массива, а значит, не более максимального индекса массива
                // цикл завершается, так как j растёт до 71-ого
                // все байты массива compressedOpenText будут наложены после исправления ошибки
                compressedOpenText[j] ^= c[j];
            }

            
            // !13=: объект block в данном случае не уничтожается, т.к. условие создания !13 противоположно условию перезаписи
-!-         // !10: объект block должен быть безопасно уничтожен
            // !14+: чтение compressedOpenText не изменяет его длину, в том числе, чтение по указателю o и o_
            // После применения xor при зашифровании compressedOpenText в данной части содержит шифротекст, который записывается в block
            // !15+: на месте недостающих байт будут нули, так как выше block безусловно очищается
(6)         if (encrypt)
(6)             BytesBuilder.CopyTo(compressedOpenText, block, 0, 71, i);
        }
    }

    // !9-: объект block не уничтожен, если compressedOpenText пуст
}

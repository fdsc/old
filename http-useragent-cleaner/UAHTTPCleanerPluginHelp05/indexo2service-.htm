<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/strict.dtd"><html>	<head>		<title>HTTP UserAgent cleaner</title><!--#include file="links.inc"-->		<meta name="description" content="Функции вкладки Сторонние: разрешение сервисных запросов">	</head>	<body><DIV align = center ><DIV id=maindiv>		<!--#include file="_begin.inc"-->			<H1>Дополнение для FireFox "HTTP UserAgent cleaner" - справка</H1>			<br><br>			<!--#include file="_support.inc"-->			<br>			<hr>			<br><br>			<!--a href="">Help in screenshots</a>			<br><br-->			<!--Справка (только на русском) -->			<br><br>				При использовании вкладки "Сторонние" в режиме блокировки всех ресурсов, кроме явно разрешённых, или в режиме фильтра https-соединений могут быть заблокированы служебные запросы, такие, как OCSP-запросы, запросы на обновление FireFox, расширений, списков блокировки и прокси расширений.<br><br>								Давайте, для начала, настроим дополнение для блокировки нешифрованных соединений. Эта функциональность обеспечивается фильтром "toHttps". Этот фильтр полностью аналогичен фильтру "https" вкладки "HTTP". Достаточно использовать какой-нибудь один из них (какой вам удобнее).				<br>				Допустим, что на всех соединениях, кроме явно разрешённых, мы хотим использовать только шифрованный канал. Создадим правило с именем "HTTPS". Введём в нём условие "!tTLS | !rTLS". Условие tTLS означает, что вкладка должна быть загружена с использованием TLS, то есть по протоколу https. Условие rTLS означает, что запрос должен быть выполнен с использованием TLS, то есть по протоколу https.<br>Условия !tTLS и !rTLS обратны указанным tTLS и rTLS, то есть срабатывают тогда, когда вкладка (!tTLS) или запрос (!rTLS) загружаются по нешифрованному соединению.<br>				Соответственно, общее условие означает, что правило сработает тогда, когда либо вкладка, либо запрос не будут выполнены по шифрованному соединению.<br>				Установим на правило фильтр "toHttps" в состояние "+". Установим тип условия на "obj" (ячейка слева второй строки).<br>				Правило будет выглядеть так:				<br><img src='i2/SERV1.png'><br><br>				При входе на любой сайт по протоколу http, фильтр toHttps этого правила теперь будет пытаться перенаправлять запросы на https либо блокировать соединение. Фильтр toHttps вкладки "Сторонние" не остаётся в логах сам по себе (или остаётся в логах под отдельным типом лога - №4), поэтому если вы хотите увидеть его в логах, используйте с ним вместе фильтр "Log:+". Фильтр toHttps автоматически не будет фильтровать OCSP-запросы, которые всегда направляются по http.				<br><br>				Всё хорошо, кроме одного. Скажем, дополнение AnonymoX обновляет некоторые данные через нешифрованное соединение, поэтому его работа с таким фильтром невозможна. Давайте настроим дополнение так, чтобы оно пропускало такие запросы, а также пропускало http-запросы при работе в приватном режиме.<br>				Создадим правило, подчинённое правилу "HTTPS", с именем "HTTPS.1". Введём тип условия "obj". Введём условие "SERVICE | PRIVATE". Добавим фильтр toHttps:- (отмена действия фильтра toHttps).<br>				Это правило будет срабатывать в приватном режиме работы либо когда будет обрабатывать служебные запросы.<br>				Условие PRIVATE задаёт, что правило работает в приватном режиме. Условие SERVICE - что правило работает со служебными запросами. Условие "SERVICE | PRIVATE" срабатывает когда одно из этих условий выполнено.				<br><img src='i2/SERV2.png'><br><br>				Теперь сервисные запросы могут проходить и без шифрования. Сервисными являются запросы на получение иконки сайта (favicon.ico), ocsp-запросы и часть из запросов браузера и дополнений.<br><br>				Теперь давайте создадим ещё одно правило верхнего уровня (жмём на правую кнопку "+" правила "HTTPS"). Назовём правило "PRIVATE & SERVICE". Оно будет собирать в себе правила для запросов в приватном режиме и сервисных запросов.<br>				Создадим подчинённое ему правило с именем "SERVICE". Введём условие "SERVICE", то есть правило будет срабатывать на служебные запросы. Добавим в правило фильтр "Request:-". То есть разрешим такие запросы. Теперь, даже если другие правила запретят служебный запрос, это правило его разрешит.<br>				Но мы забыли сделать два маленьких шриха. Чтобы это правило разрешило запросы, которые уже запрещены другими правилами, у него должен быть более высокий приоритет, чем для запрещающих правил. Давайте увеличим приоритет с 5 до 4 для правила "PRIVATE & SERVICE", и с 5 до 3-х для правила "SERVICE".<br>				Я попытался выполнить запрос к "http://relaxtime.8vs.ru/" и получил следующее.				<br><img src='i2/SERV3.png'><br><br>				Две последние строки лога говорят о том, что в нашем правиле "SERVICE" ошибка. Дело в том, что мы забыли перенастроить тип условия для этого правила с "url" на "obj". Давайте перенастроим. Получим следующее:				<br><img src='i2/SERV4.png'><br><br>				Обратите внимание. Отличие этого правила от похожего правила выше состоит в том, что правило выше разрешает нешифрованные служебные запросы, даже если нешифрованные запросы запрещены, а это правило разрешает все служебные запросы, даже если все служебные запросы запрещены. И то, и другое правила могут вам понадобиться.				<br><br>				В принципе, нам совершенно не нужно получать картинки вкладок (favicon.ico), однако отделить эти запросы от других сервисных у меня не получилось.<br>				Некоторые дополнения при запросе с приватного окна браузера также отсылают и принимают сообщения в приватном режиме. При этом, такие дополнения формируют !SERVICE-запросы. Но, в принципе, браузер и дополнения могут формировать и приватные сервис-запросы. Поэтому запрещать приватные сервис запросы не стоит, если, конечно, вы не уверены в том, что делаете.<br><br>				В правиле "PRIVATE & SERVICE" вы можете создать подчинённое правило "PRIVATE" с условием "PRIVATE". И там, в подчинённых правилах, вводить свои правила, действующие только для приватного режима браузера.				<br><br><br><br>								Вернёмся к правилу "HTTPS". Если мы захотим зайти, скажем, на livejournal.com, который работает без шифрования, то дополнение заблокирует наш запрос. Чтобы этого не было, создадим правило, подчинённое правилу "HTTPS", с названием "HTTPS.Не https-сайты". Затем создадим уже ему подчинённое правило с именем "HTTPS.Не https-сайты.livejournal.com". Введём в него условие "td[:1]=livejournal.com". Добавим фильтр toHttps:-. Теперь мы сможем заходить на эту блог-площадку без шифрования.				<br><img src='i2/SERV5.png'><br><br>				<br><br><br><br>								Подведём итог.				<ul>				<li>Условие PRIVATE действует для запросов, работающих в приватном режиме браузера. !PRIVATE в неприватном режиме.				<li>Условие tTLS действует для вкладок, работающих через протокол https, то есть через шифрованное с помощью протокола TLS соединение. Условие !tTLS обратное - только для нешифрованных вкладок.				<li>Условие rTLS действует для запросов, работающих через протокол https. !rTLS - обратное условие.				<li>Условие SERVICE действует для служебных запросов, не связанных с загрузкой просматриваемых пользователем документов, таких как OCSP-запросов, обновлений FireFox, дополнений и их данных (хотя они могут посылать такие запросы и !SERVICE).				<li>Фильтр toHttps будет пытаться перенаправить запросы на шифрованное соединение, если они ещё нешифрованны. OCSP-запросы он не блокирует. В логах остаётся только если лог содержит какой-либо другой сработавший фильтр (например, фильтр Log).				<li>Условие OCSP действует на OCSP-запросы. Если вы хотите запретить все запросы, включая сервисные, через фильтр Request, но хотите оставить разрешёнными OCSP-запросы, то используйте это условие (например, в выше приведённом правиле "SERVICE" можно поставить условие "OCSP" вместо "SERVICE").				</ul>				<br><br><br><br>				<!--#include file="_menu.inc"-->				<br><br><DIV></DIV><!--#include file="mcyandex.inc"--></BODY></html>